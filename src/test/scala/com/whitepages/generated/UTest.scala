/**
 * Generated by Scrooge
 *   version: 3.16.40
 *   rev: c3bbc209edcec136fff0d50ec6d0bf27d31c6aa2
 *   built at: 20140917-102732
 */
package com.whitepages.generated

import com.twitter.scrooge.{ThriftStruct, ThriftStructCodec3, ThriftStructFieldInfo, ThriftUnion, TFieldBlob}
import org.apache.thrift.protocol._
import java.nio.ByteBuffer
import java.util.Arrays
import scala.collection.immutable.{Map => immutable$Map}
import scala.collection.mutable.{
  ArrayBuffer => mutable$ArrayBuffer, Buffer => mutable$Buffer,
  HashMap => mutable$HashMap, HashSet => mutable$HashSet}
import scala.collection.{Map, Set}

import com.persist.JsonOps._
import com.persist.json._
import com.persist.Exceptions.MappingException

@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
sealed trait UTest extends ThriftUnion with ThriftStruct

private object UTestDecoder {
  def apply(_iprot: TProtocol, newUnknown: TFieldBlob => UTest): UTest = {
    var _result: UTest = null
    _iprot.readStructBegin()
    val _field = _iprot.readFieldBegin()
    _field.id match {
      case 1 => { /* s */
        _field.`type` match {
          case TType.STRING => {
            _result = UTest.S({
              _iprot.readString()
            })
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
      }
      case 2 => { /* c */
        _field.`type` match {
          case TType.STRUCT => {
            _result = UTest.C({
              com.whitepages.generated.Compound.decode(_iprot)
            })
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
      }
      case 3 => { /* m */
        _field.`type` match {
          case TType.MAP => {
            _result = UTest.M({
              val _map = _iprot.readMapBegin()
              if (_map.size == 0) {
                _iprot.readMapEnd()
                Map.empty[Compound, String]
              } else {
                val _rv = new mutable$HashMap[Compound, String]
                var _i = 0
                while (_i < _map.size) {
                  val _key = {
                      Compound.decode(_iprot)
  
                  }
                  val _value = {
                      _iprot.readString()
  
                  }
                  _rv(_key) = _value
                  _i += 1
                }
                _iprot.readMapEnd()
                _rv
              }
            })
          }
          case _ => TProtocolUtil.skip(_iprot, _field.`type`)
        }
      }
      case _ =>
        if (_field.`type` != TType.STOP) {
          _result = newUnknown(TFieldBlob.read(_field, _iprot))
        } else {
          TProtocolUtil.skip(_iprot, _field.`type`)
        }
    }
    if (_field.`type` != TType.STOP) {
      _iprot.readFieldEnd()
      var _done = false
      var _moreThanOne = false
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP)
          _done = true
        else {
          _moreThanOne = true
          TProtocolUtil.skip(_iprot, _field.`type`)
          _iprot.readFieldEnd()
        }
      }
      if (_moreThanOne) {
        _iprot.readStructEnd()
        throw new TProtocolException("Cannot read a TUnion with more than one set value!")
      }
    }
    _iprot.readStructEnd()
    if (_result == null)
      throw new TProtocolException("Cannot read a TUnion with no set value!")
    _result
  }
}

object UTestHelper {
  type SAlias = String

  def withoutPassthroughFields_S(obj: UTest.S): UTest.S = {
    val field = obj.s
      UTest.S(
        field
      )
    }

  
  val SKeyTypeManifest = None
  val SValueTypeManifest = None
  type CAlias = com.whitepages.generated.Compound

  def withoutPassthroughFields_C(obj: UTest.C): UTest.C = {
    val field = obj.c
      UTest.C(
        Compound.withoutPassthroughFields(field)
      )
    }

  
  val CKeyTypeManifest = None
  val CValueTypeManifest = None
  type MAlias = Map[Compound, String]

  def withoutPassthroughFields_M(obj: UTest.M): UTest.M = {
    val field = obj.m
      UTest.M(
        field.map { case (key, value) =>
            val newKey = {
            val field = key
            Compound.withoutPassthroughFields(field)
          }
  
        
            val newValue = {
            val field = value
            field
          }
  
        
          newKey -> newValue
        }
      )
    }

  val MDefaultValue = Map[Compound, String]()
  val MKeyTypeManifest = Some(implicitly[Manifest[Compound]])
  val MValueTypeManifest = Some(implicitly[Manifest[String]])
}


@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
object UTest extends ThriftStructCodec3[UTest] {
  val Union = new TStruct("UTest")
  val SField = new TField("s", TType.STRING, 1)
  val SFieldManifest = implicitly[Manifest[S]]
  val CField = new TField("c", TType.STRUCT, 2)
  val CFieldManifest = implicitly[Manifest[C]]
  val MField = new TField("m", TType.MAP, 3)
  val MFieldManifest = implicitly[Manifest[M]]

  lazy val structAnnotations: immutable$Map[String, String] =
    immutable$Map[String, String](
    )

  override def encode(_item: UTest, _oprot: TProtocol) { _item.write(_oprot) }
  override def decode(_iprot: TProtocol): UTest = UTestDecoder(_iprot, UnknownUnionField(_))

  import com.twitter.scrooge.serialization.ThriftCodec

  implicit val thriftCodec = new ThriftCodec[UTest] {
    def encode(obj: UTest, protocol: TProtocol) { UTest.encode(obj, protocol) }
    def decode(protocol: TProtocol) = UTest.decode(protocol)
  }

  def apply(_iprot: TProtocol): UTest = decode(_iprot)

  import UTestHelper._

  def withoutPassthroughFields(struct: UTest): UTest = {
    struct match {
      case obj: S => withoutPassthroughFields_S(obj)
      case obj: C => withoutPassthroughFields_C(obj)
      case obj: M => withoutPassthroughFields_M(obj)
      case unknown: UnknownUnionField => unknown // by definition pass-through
    }
  }

  implicit object JsonReadCodec extends ReadCodec[UTest] {
    def read(json: Json): UTest = {
      val jsObject = ReadCodec.castOrThrow(json)
      val onlyChild = jsObject.keys.headOption.getOrElse(throw new MappingException(s"Expected json to contain a single child in order to read into union but found: $json"))
      onlyChild match {        case "s" => S(s = com.persist.json.read[String](jsObject.values.head))
                case "c" => C(c = com.persist.json.read[com.whitepages.generated.Compound](jsObject.values.head))
                case "m" => M(m = com.persist.json.read[Map[Compound, String]](jsObject.values.head))
        
      }
    }
  }
  implicit object JsonWriteCodec extends WriteCodec[UTest] {
    def write(obj: UTest): Json = obj match {      case S(x) => JsonObject("s" -> com.persist.json.toJson(x))
          case C(x) => JsonObject("c" -> com.persist.json.toJson(x))
          case M(x) => JsonObject("m" -> com.persist.json.toJson(x))
    
    }
  }

  object S {
    def withoutPassthroughFields(obj: S): S = withoutPassthroughFields_S(obj)

    val fieldInfo =
      new ThriftStructFieldInfo(
        SField,
        false,
        manifest[SAlias],
        SKeyTypeManifest,
        SValueTypeManifest,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
  }

  case class S(s: SAlias) extends UTest {
    override def write(_oprot: TProtocol) {
      if (s == null)
        throw new TProtocolException("Cannot write a TUnion with no set value!")
      _oprot.writeStructBegin(Union)
      if (s ne null) {
        val s_item = s
        _oprot.writeFieldBegin(SField)
        _oprot.writeString(s_item)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  }

  object C {
    def withoutPassthroughFields(obj: C): C = withoutPassthroughFields_C(obj)

    val fieldInfo =
      new ThriftStructFieldInfo(
        CField,
        false,
        manifest[CAlias],
        CKeyTypeManifest,
        CValueTypeManifest,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
  }

  case class C(c: CAlias) extends UTest {
    override def write(_oprot: TProtocol) {
      if (c == null)
        throw new TProtocolException("Cannot write a TUnion with no set value!")
      _oprot.writeStructBegin(Union)
      if (c ne null) {
        val c_item = c
        _oprot.writeFieldBegin(CField)
        c_item.write(_oprot)
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  }

  object M {
    def withoutPassthroughFields(obj: M): M = withoutPassthroughFields_M(obj)

    val fieldInfo =
      new ThriftStructFieldInfo(
        MField,
        false,
        manifest[MAlias],
        MKeyTypeManifest,
        MValueTypeManifest,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
  }

  case class M(m: MAlias = MDefaultValue) extends UTest {
    override def write(_oprot: TProtocol) {
      if (m == null)
        throw new TProtocolException("Cannot write a TUnion with no set value!")
      _oprot.writeStructBegin(Union)
      if (m ne null) {
        val m_item = m
        _oprot.writeFieldBegin(MField)
        _oprot.writeMapBegin(new TMap(TType.STRUCT, TType.STRING, m_item.size))
        m_item.foreach { _pair =>
          val m_item_key = _pair._1
          val m_item_value = _pair._2
          m_item_key.write(_oprot)
          _oprot.writeString(m_item_value)
        }
        _oprot.writeMapEnd()
        _oprot.writeFieldEnd()
      }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  }

  case class UnknownUnionField private[UTest](private val field: TFieldBlob) extends UTest {
    override def write(_oprot: TProtocol) {
      _oprot.writeStructBegin(Union)
      field.write(_oprot)
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  }
}