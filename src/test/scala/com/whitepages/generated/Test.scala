/**
 * Generated by Scrooge
 *   version: 3.16.40
 *   rev: c3bbc209edcec136fff0d50ec6d0bf27d31c6aa2
 *   built at: 20140917-102732
 */
package com.whitepages.generated

import com.twitter.scrooge.{
  TFieldBlob, ThriftService, ThriftStruct, ThriftStructCodec, ThriftStructCodec3, ThriftStructFieldInfo, ThriftUtil}
import java.nio.ByteBuffer
import java.util.Arrays
import org.apache.thrift.protocol._
import org.apache.thrift.transport.TTransport
import org.apache.thrift.TApplicationException
import org.apache.thrift.transport.TMemoryBuffer
import scala.collection.immutable.{Map => immutable$Map}
import scala.collection.mutable.{
  Builder,
  ArrayBuffer => mutable$ArrayBuffer, Buffer => mutable$Buffer,
  HashMap => mutable$HashMap, HashSet => mutable$HashSet}
import scala.collection.{Map, Set}

import scala.language.higherKinds


@javax.annotation.Generated(value = Array("com.twitter.scrooge.Compiler"))
trait Test[+MM[_]] extends ThriftService {
  
  def testcmd(request: Request): MM[Response]
  
  def testcmd1(addr1: String, addr2: String): MM[Int]
  
  def testcmd2(names: Seq[String] = Seq[String]()): MM[Int]
  
  def testcmd3(in1: UTest): MM[UTest]
  
  def shortIdToUuid(ids: String): MM[String]
  
  def casechecker(caseChecker: CaseChecker): MM[CaseChecker]
  
  def camelCase(i: Int): MM[Int]
  
  def snakeCase(i: Int): MM[Int]
}


object Test {
  
  import com.persist.JsonOps._
  import com.persist.json._
  import com.persist.Exceptions.MappingException
  import scala.util.Try
  
  
  object testcmd$args extends ThriftStructCodec3[testcmd$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("testcmd_args")
    val RequestField = new TField("request", TType.STRUCT, 1)
    val RequestFieldManifest = implicitly[Manifest[Request]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        RequestField,
        false,
        RequestFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: testcmd$args) {
    }
  
    def withoutPassthroughFields(original: testcmd$args): testcmd$args =
      new testcmd$args(
        request =
          {
            val field = original.request
            Request.withoutPassthroughFields(field)
          }
      )
  
    override def encode(_item: testcmd$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): testcmd$args = {
      var request: Request = null
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 =>
              _field.`type` match {
                case TType.STRUCT => {
                  request = readRequestValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.STRUCT
            
                  throw new TProtocolException(
                    "Received wrong type for field 'request' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new testcmd$args(
        request,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      request: Request
    ): testcmd$args =
      new testcmd$args(
        request
      )
  
    def unapply(_item: testcmd$args): Option[Request] = Some(_item.request)
  
    implicit val jsonReadCodec = new ReadCodec[testcmd$args] {
      def read(json: Json) = {
        val map = ReadCodec.castOrThrow(json)
              val fieldValuerequest = map.getOrElse("request", throw new MappingException(s"Expected field request on JsonObject $map"))
      
        testcmd$args(      request = Try(com.persist.json.read[Request](fieldValuerequest)).recover {
          case MappingException(msg, path) => throw MappingException(msg, s"request/$path")
        }.get
      
        )
      }
     }
    implicit val jsonWriteCodec = new WriteCodec[testcmd$args] {
      def write(obj: testcmd$args) = {
        val fields = List(        
          Some("request" -> com.persist.json.toJson(obj.request))
        )
        fields.flatten.toMap
      }
    }
  
    import com.twitter.scrooge.serialization._
  
    implicit val thriftCodec = new ThriftCodec[testcmd$args] {
      def decode(protocol: TProtocol): testcmd$args = testcmd$args.decode(protocol)
      def encode(obj: testcmd$args, protocol: TProtocol) { testcmd$args.encode(obj, protocol) }
    }
  
    private def readRequestValue(_iprot: TProtocol): Request = {
      Request.decode(_iprot)
    }
  
    private def writeRequestField(request_item: Request, _oprot: TProtocol) {
      _oprot.writeFieldBegin(RequestField)
      writeRequestValue(request_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeRequestValue(request_item: Request, _oprot: TProtocol) {
      request_item.write(_oprot)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class testcmd$args(
      val request: Request,
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[Request]
    with java.io.Serializable
  {
    import testcmd$args._
      def this(
        request: Request
      ) = this(
        request,
        Map.empty
      )
  
    def _1 = request
  
  
    override def write(_oprot: TProtocol) {
      testcmd$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (request ne null) writeRequestField(request, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      request: Request = this.request,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): testcmd$args =
      new testcmd$args(
        request,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[testcmd$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[testcmd$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.request
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "testcmd$args"
  }
  
  import com.persist.JsonOps._
  import com.persist.json._
  import com.persist.Exceptions.MappingException
  import scala.util.Try
  
  
  object testcmd$result extends ThriftStructCodec3[testcmd$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("testcmd_result")
    val SuccessField = new TField("success", TType.STRUCT, 0)
    val SuccessFieldManifest = implicitly[Manifest[Response]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        SuccessField,
        true,
        SuccessFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: testcmd$result) {
    }
  
    def withoutPassthroughFields(original: testcmd$result): testcmd$result =
      new testcmd$result(
        success =
          {
            val field = original.success
            field.map { field =>
              Response.withoutPassthroughFields(field)
            }
          }
      )
  
    override def encode(_item: testcmd$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): testcmd$result = {
      var success: Option[Response] = None
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 =>
              _field.`type` match {
                case TType.STRUCT => {
                  success = Some(readSuccessValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.STRUCT
            
                  throw new TProtocolException(
                    "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new testcmd$result(
        success,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      success: Option[Response] = None
    ): testcmd$result =
      new testcmd$result(
        success
      )
  
    def unapply(_item: testcmd$result): Option[Option[Response]] = Some(_item.success)
  
    implicit val jsonReadCodec = new ReadCodec[testcmd$result] {
      def read(json: Json) = {
        val map = ReadCodec.castOrThrow(json)
              val fieldValuesuccess = map.getOrElse("success", jnull)
      
        testcmd$result(      success = Try(com.persist.json.read[Option[Response]](fieldValuesuccess)).recover {
          case MappingException(msg, path) => throw MappingException(msg, s"success/$path")
        }.get
      
        )
      }
     }
    implicit val jsonWriteCodec = new WriteCodec[testcmd$result] {
      def write(obj: testcmd$result) = {
        val fields = List(        if(obj.success.isDefined) Some("success" -> com.persist.json.toJson(obj.success.get)) else None
        
        )
        fields.flatten.toMap
      }
    }
  
    import com.twitter.scrooge.serialization._
  
    implicit val thriftCodec = new ThriftCodec[testcmd$result] {
      def decode(protocol: TProtocol): testcmd$result = testcmd$result.decode(protocol)
      def encode(obj: testcmd$result, protocol: TProtocol) { testcmd$result.encode(obj, protocol) }
    }
  
    private def readSuccessValue(_iprot: TProtocol): Response = {
      Response.decode(_iprot)
    }
  
    private def writeSuccessField(success_item: Response, _oprot: TProtocol) {
      _oprot.writeFieldBegin(SuccessField)
      writeSuccessValue(success_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeSuccessValue(success_item: Response, _oprot: TProtocol) {
      success_item.write(_oprot)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class testcmd$result(
      val success: Option[Response],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[Option[Response]]
    with java.io.Serializable
  {
    import testcmd$result._
      def this(
        success: Option[Response] = None
      ) = this(
        success,
        Map.empty
      )
  
    def _1 = success
  
  
    override def write(_oprot: TProtocol) {
      testcmd$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) writeSuccessField(success.get, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[Response] = this.success,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): testcmd$result =
      new testcmd$result(
        success,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[testcmd$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[testcmd$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.success
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "testcmd$result"
  }
  
  import com.persist.JsonOps._
  import com.persist.json._
  import com.persist.Exceptions.MappingException
  import scala.util.Try
  
  
  object testcmd1$args extends ThriftStructCodec3[testcmd1$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("testcmd1_args")
    val Addr1Field = new TField("addr1", TType.STRING, 1)
    val Addr1FieldManifest = implicitly[Manifest[String]]
    val Addr2Field = new TField("addr2", TType.STRING, 2)
    val Addr2FieldManifest = implicitly[Manifest[String]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        Addr1Field,
        false,
        Addr1FieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      ),
      new ThriftStructFieldInfo(
        Addr2Field,
        false,
        Addr2FieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: testcmd1$args) {
    }
  
    def withoutPassthroughFields(original: testcmd1$args): testcmd1$args =
      new testcmd1$args(
        addr1 =
          {
            val field = original.addr1
            field
          },
        addr2 =
          {
            val field = original.addr2
            field
          }
      )
  
    override def encode(_item: testcmd1$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): testcmd1$args = {
      var addr1: String = null
      var addr2: String = null
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 =>
              _field.`type` match {
                case TType.STRING => {
                  addr1 = readAddr1Value(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.STRING
            
                  throw new TProtocolException(
                    "Received wrong type for field 'addr1' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case 2 =>
              _field.`type` match {
                case TType.STRING => {
                  addr2 = readAddr2Value(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.STRING
            
                  throw new TProtocolException(
                    "Received wrong type for field 'addr2' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new testcmd1$args(
        addr1,
        addr2,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      addr1: String,
      addr2: String
    ): testcmd1$args =
      new testcmd1$args(
        addr1,
        addr2
      )
  
    def unapply(_item: testcmd1$args): Option[scala.Product2[String, String]] = Some(_item)
  
    implicit val jsonReadCodec = new ReadCodec[testcmd1$args] {
      def read(json: Json) = {
        val map = ReadCodec.castOrThrow(json)
              val fieldValueaddr1 = map.getOrElse("addr1", throw new MappingException(s"Expected field addr1 on JsonObject $map"))
              val fieldValueaddr2 = map.getOrElse("addr2", throw new MappingException(s"Expected field addr2 on JsonObject $map"))
      
        testcmd1$args(      addr1 = Try(com.persist.json.read[String](fieldValueaddr1)).recover {
          case MappingException(msg, path) => throw MappingException(msg, s"addr1/$path")
        }.get
        ,      addr2 = Try(com.persist.json.read[String](fieldValueaddr2)).recover {
          case MappingException(msg, path) => throw MappingException(msg, s"addr2/$path")
        }.get
      
        )
      }
     }
    implicit val jsonWriteCodec = new WriteCodec[testcmd1$args] {
      def write(obj: testcmd1$args) = {
        val fields = List(        
          Some("addr1" -> com.persist.json.toJson(obj.addr1)),        
          Some("addr2" -> com.persist.json.toJson(obj.addr2))
        )
        fields.flatten.toMap
      }
    }
  
    import com.twitter.scrooge.serialization._
  
    implicit val thriftCodec = new ThriftCodec[testcmd1$args] {
      def decode(protocol: TProtocol): testcmd1$args = testcmd1$args.decode(protocol)
      def encode(obj: testcmd1$args, protocol: TProtocol) { testcmd1$args.encode(obj, protocol) }
    }
  
    private def readAddr1Value(_iprot: TProtocol): String = {
      _iprot.readString()
    }
  
    private def writeAddr1Field(addr1_item: String, _oprot: TProtocol) {
      _oprot.writeFieldBegin(Addr1Field)
      writeAddr1Value(addr1_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeAddr1Value(addr1_item: String, _oprot: TProtocol) {
      _oprot.writeString(addr1_item)
    }
  
    private def readAddr2Value(_iprot: TProtocol): String = {
      _iprot.readString()
    }
  
    private def writeAddr2Field(addr2_item: String, _oprot: TProtocol) {
      _oprot.writeFieldBegin(Addr2Field)
      writeAddr2Value(addr2_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeAddr2Value(addr2_item: String, _oprot: TProtocol) {
      _oprot.writeString(addr2_item)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class testcmd1$args(
      val addr1: String,
      val addr2: String,
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product2[String, String]
    with java.io.Serializable
  {
    import testcmd1$args._
      def this(
        addr1: String,
        addr2: String
      ) = this(
        addr1,
        addr2,
        Map.empty
      )
  
    def _1 = addr1
    def _2 = addr2
  
  
    override def write(_oprot: TProtocol) {
      testcmd1$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (addr1 ne null) writeAddr1Field(addr1, _oprot)
      if (addr2 ne null) writeAddr2Field(addr2, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      addr1: String = this.addr1,
      addr2: String = this.addr2,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): testcmd1$args =
      new testcmd1$args(
        addr1,
        addr2,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[testcmd1$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[testcmd1$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 2
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.addr1
      case 1 => this.addr2
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "testcmd1$args"
  }
  
  import com.persist.JsonOps._
  import com.persist.json._
  import com.persist.Exceptions.MappingException
  import scala.util.Try
  
  
  object testcmd1$result extends ThriftStructCodec3[testcmd1$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("testcmd1_result")
    val SuccessField = new TField("success", TType.I32, 0)
    val SuccessFieldManifest = implicitly[Manifest[Int]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        SuccessField,
        true,
        SuccessFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: testcmd1$result) {
    }
  
    def withoutPassthroughFields(original: testcmd1$result): testcmd1$result =
      new testcmd1$result(
        success =
          {
            val field = original.success
            field.map { field =>
              field
            }
          }
      )
  
    override def encode(_item: testcmd1$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): testcmd1$result = {
      var success: Option[Int] = None
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 =>
              _field.`type` match {
                case TType.I32 => {
                  success = Some(readSuccessValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.I32
            
                  throw new TProtocolException(
                    "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new testcmd1$result(
        success,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      success: Option[Int] = None
    ): testcmd1$result =
      new testcmd1$result(
        success
      )
  
    def unapply(_item: testcmd1$result): Option[Option[Int]] = Some(_item.success)
  
    implicit val jsonReadCodec = new ReadCodec[testcmd1$result] {
      def read(json: Json) = {
        val map = ReadCodec.castOrThrow(json)
              val fieldValuesuccess = map.getOrElse("success", jnull)
      
        testcmd1$result(      success = Try(com.persist.json.read[Option[Int]](fieldValuesuccess)).recover {
          case MappingException(msg, path) => throw MappingException(msg, s"success/$path")
        }.get
      
        )
      }
     }
    implicit val jsonWriteCodec = new WriteCodec[testcmd1$result] {
      def write(obj: testcmd1$result) = {
        val fields = List(        if(obj.success.isDefined) Some("success" -> com.persist.json.toJson(obj.success.get)) else None
        
        )
        fields.flatten.toMap
      }
    }
  
    import com.twitter.scrooge.serialization._
  
    implicit val thriftCodec = new ThriftCodec[testcmd1$result] {
      def decode(protocol: TProtocol): testcmd1$result = testcmd1$result.decode(protocol)
      def encode(obj: testcmd1$result, protocol: TProtocol) { testcmd1$result.encode(obj, protocol) }
    }
  
    private def readSuccessValue(_iprot: TProtocol): Int = {
      _iprot.readI32()
    }
  
    private def writeSuccessField(success_item: Int, _oprot: TProtocol) {
      _oprot.writeFieldBegin(SuccessField)
      writeSuccessValue(success_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeSuccessValue(success_item: Int, _oprot: TProtocol) {
      _oprot.writeI32(success_item)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class testcmd1$result(
      val success: Option[Int],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[Option[Int]]
    with java.io.Serializable
  {
    import testcmd1$result._
      def this(
        success: Option[Int] = None
      ) = this(
        success,
        Map.empty
      )
  
    def _1 = success
  
  
    override def write(_oprot: TProtocol) {
      testcmd1$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) writeSuccessField(success.get, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[Int] = this.success,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): testcmd1$result =
      new testcmd1$result(
        success,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[testcmd1$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[testcmd1$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.success
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "testcmd1$result"
  }
  
  import com.persist.JsonOps._
  import com.persist.json._
  import com.persist.Exceptions.MappingException
  import scala.util.Try
  
  
  object testcmd2$args extends ThriftStructCodec3[testcmd2$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("testcmd2_args")
    val NamesField = new TField("names", TType.LIST, 1)
    val NamesFieldManifest = implicitly[Manifest[Seq[String]]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        NamesField,
        false,
        NamesFieldManifest,
        None,
        Some(implicitly[Manifest[String]]),
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: testcmd2$args) {
    }
  
    def withoutPassthroughFields(original: testcmd2$args): testcmd2$args =
      new testcmd2$args(
        names =
          {
            val field = original.names
            field.map { field =>
              field
            }
          }
      )
  
    override def encode(_item: testcmd2$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): testcmd2$args = {
      var names: Seq[String] = Seq[String]()
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 =>
              _field.`type` match {
                case TType.LIST => {
                  names = readNamesValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.LIST
            
                  throw new TProtocolException(
                    "Received wrong type for field 'names' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new testcmd2$args(
        names,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      names: Seq[String] = Seq[String]()
    ): testcmd2$args =
      new testcmd2$args(
        names
      )
  
    def unapply(_item: testcmd2$args): Option[Seq[String]] = Some(_item.names)
  
    implicit val jsonReadCodec = new ReadCodec[testcmd2$args] {
      def read(json: Json) = {
        val map = ReadCodec.castOrThrow(json)
              val fieldValuenames = map.getOrElse("names", throw new MappingException(s"Expected field names on JsonObject $map"))
      
        testcmd2$args(      names = Try(com.persist.json.read[Seq[String]](fieldValuenames)).recover {
          case MappingException(msg, path) => throw MappingException(msg, s"names/$path")
        }.get
      
        )
      }
     }
    implicit val jsonWriteCodec = new WriteCodec[testcmd2$args] {
      def write(obj: testcmd2$args) = {
        val fields = List(        
          Some("names" -> com.persist.json.toJson(obj.names))
        )
        fields.flatten.toMap
      }
    }
  
    import com.twitter.scrooge.serialization._
  
    implicit val thriftCodec = new ThriftCodec[testcmd2$args] {
      def decode(protocol: TProtocol): testcmd2$args = testcmd2$args.decode(protocol)
      def encode(obj: testcmd2$args, protocol: TProtocol) { testcmd2$args.encode(obj, protocol) }
    }
  
    private def readNamesValue(_iprot: TProtocol): Seq[String] = {
      val _list = _iprot.readListBegin()
      if (_list.size == 0) {
        _iprot.readListEnd()
        Nil
      } else {
        val _rv = new mutable$ArrayBuffer[String](_list.size)
        var _i = 0
        while (_i < _list.size) {
          _rv += {
              _iprot.readString()
  
          }
          _i += 1
        }
        _iprot.readListEnd()
        _rv
      }
    }
  
    private def writeNamesField(names_item: Seq[String], _oprot: TProtocol) {
      _oprot.writeFieldBegin(NamesField)
      writeNamesValue(names_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeNamesValue(names_item: Seq[String], _oprot: TProtocol) {
      _oprot.writeListBegin(new TList(TType.STRING, names_item.size))
      names_item.foreach { names_item_element =>
        _oprot.writeString(names_item_element)
      }
      _oprot.writeListEnd()
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class testcmd2$args(
      val names: Seq[String],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[Seq[String]]
    with java.io.Serializable
  {
    import testcmd2$args._
      def this(
        names: Seq[String] = Seq[String]()
      ) = this(
        names,
        Map.empty
      )
  
    def _1 = names
  
  
    override def write(_oprot: TProtocol) {
      testcmd2$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (names ne null) writeNamesField(names, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      names: Seq[String] = this.names,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): testcmd2$args =
      new testcmd2$args(
        names,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[testcmd2$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[testcmd2$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.names
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "testcmd2$args"
  }
  
  import com.persist.JsonOps._
  import com.persist.json._
  import com.persist.Exceptions.MappingException
  import scala.util.Try
  
  
  object testcmd2$result extends ThriftStructCodec3[testcmd2$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("testcmd2_result")
    val SuccessField = new TField("success", TType.I32, 0)
    val SuccessFieldManifest = implicitly[Manifest[Int]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        SuccessField,
        true,
        SuccessFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: testcmd2$result) {
    }
  
    def withoutPassthroughFields(original: testcmd2$result): testcmd2$result =
      new testcmd2$result(
        success =
          {
            val field = original.success
            field.map { field =>
              field
            }
          }
      )
  
    override def encode(_item: testcmd2$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): testcmd2$result = {
      var success: Option[Int] = None
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 =>
              _field.`type` match {
                case TType.I32 => {
                  success = Some(readSuccessValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.I32
            
                  throw new TProtocolException(
                    "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new testcmd2$result(
        success,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      success: Option[Int] = None
    ): testcmd2$result =
      new testcmd2$result(
        success
      )
  
    def unapply(_item: testcmd2$result): Option[Option[Int]] = Some(_item.success)
  
    implicit val jsonReadCodec = new ReadCodec[testcmd2$result] {
      def read(json: Json) = {
        val map = ReadCodec.castOrThrow(json)
              val fieldValuesuccess = map.getOrElse("success", jnull)
      
        testcmd2$result(      success = Try(com.persist.json.read[Option[Int]](fieldValuesuccess)).recover {
          case MappingException(msg, path) => throw MappingException(msg, s"success/$path")
        }.get
      
        )
      }
     }
    implicit val jsonWriteCodec = new WriteCodec[testcmd2$result] {
      def write(obj: testcmd2$result) = {
        val fields = List(        if(obj.success.isDefined) Some("success" -> com.persist.json.toJson(obj.success.get)) else None
        
        )
        fields.flatten.toMap
      }
    }
  
    import com.twitter.scrooge.serialization._
  
    implicit val thriftCodec = new ThriftCodec[testcmd2$result] {
      def decode(protocol: TProtocol): testcmd2$result = testcmd2$result.decode(protocol)
      def encode(obj: testcmd2$result, protocol: TProtocol) { testcmd2$result.encode(obj, protocol) }
    }
  
    private def readSuccessValue(_iprot: TProtocol): Int = {
      _iprot.readI32()
    }
  
    private def writeSuccessField(success_item: Int, _oprot: TProtocol) {
      _oprot.writeFieldBegin(SuccessField)
      writeSuccessValue(success_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeSuccessValue(success_item: Int, _oprot: TProtocol) {
      _oprot.writeI32(success_item)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class testcmd2$result(
      val success: Option[Int],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[Option[Int]]
    with java.io.Serializable
  {
    import testcmd2$result._
      def this(
        success: Option[Int] = None
      ) = this(
        success,
        Map.empty
      )
  
    def _1 = success
  
  
    override def write(_oprot: TProtocol) {
      testcmd2$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) writeSuccessField(success.get, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[Int] = this.success,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): testcmd2$result =
      new testcmd2$result(
        success,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[testcmd2$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[testcmd2$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.success
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "testcmd2$result"
  }
  
  import com.persist.JsonOps._
  import com.persist.json._
  import com.persist.Exceptions.MappingException
  import scala.util.Try
  
  
  object testcmd3$args extends ThriftStructCodec3[testcmd3$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("testcmd3_args")
    val In1Field = new TField("in1", TType.STRUCT, 1)
    val In1FieldManifest = implicitly[Manifest[UTest]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        In1Field,
        false,
        In1FieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: testcmd3$args) {
    }
  
    def withoutPassthroughFields(original: testcmd3$args): testcmd3$args =
      new testcmd3$args(
        in1 =
          {
            val field = original.in1
            UTest.withoutPassthroughFields(field)
          }
      )
  
    override def encode(_item: testcmd3$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): testcmd3$args = {
      var in1: UTest = null
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 =>
              _field.`type` match {
                case TType.STRUCT => {
                  in1 = readIn1Value(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.STRUCT
            
                  throw new TProtocolException(
                    "Received wrong type for field 'in1' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new testcmd3$args(
        in1,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      in1: UTest
    ): testcmd3$args =
      new testcmd3$args(
        in1
      )
  
    def unapply(_item: testcmd3$args): Option[UTest] = Some(_item.in1)
  
    implicit val jsonReadCodec = new ReadCodec[testcmd3$args] {
      def read(json: Json) = {
        val map = ReadCodec.castOrThrow(json)
              val fieldValuein1 = map.getOrElse("in1", throw new MappingException(s"Expected field in1 on JsonObject $map"))
      
        testcmd3$args(      in1 = Try(com.persist.json.read[UTest](fieldValuein1)).recover {
          case MappingException(msg, path) => throw MappingException(msg, s"in1/$path")
        }.get
      
        )
      }
     }
    implicit val jsonWriteCodec = new WriteCodec[testcmd3$args] {
      def write(obj: testcmd3$args) = {
        val fields = List(        
          Some("in1" -> com.persist.json.toJson(obj.in1))
        )
        fields.flatten.toMap
      }
    }
  
    import com.twitter.scrooge.serialization._
  
    implicit val thriftCodec = new ThriftCodec[testcmd3$args] {
      def decode(protocol: TProtocol): testcmd3$args = testcmd3$args.decode(protocol)
      def encode(obj: testcmd3$args, protocol: TProtocol) { testcmd3$args.encode(obj, protocol) }
    }
  
    private def readIn1Value(_iprot: TProtocol): UTest = {
      UTest.decode(_iprot)
    }
  
    private def writeIn1Field(in1_item: UTest, _oprot: TProtocol) {
      _oprot.writeFieldBegin(In1Field)
      writeIn1Value(in1_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeIn1Value(in1_item: UTest, _oprot: TProtocol) {
      in1_item.write(_oprot)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class testcmd3$args(
      val in1: UTest,
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[UTest]
    with java.io.Serializable
  {
    import testcmd3$args._
      def this(
        in1: UTest
      ) = this(
        in1,
        Map.empty
      )
  
    def _1 = in1
  
  
    override def write(_oprot: TProtocol) {
      testcmd3$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (in1 ne null) writeIn1Field(in1, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      in1: UTest = this.in1,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): testcmd3$args =
      new testcmd3$args(
        in1,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[testcmd3$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[testcmd3$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.in1
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "testcmd3$args"
  }
  
  import com.persist.JsonOps._
  import com.persist.json._
  import com.persist.Exceptions.MappingException
  import scala.util.Try
  
  
  object testcmd3$result extends ThriftStructCodec3[testcmd3$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("testcmd3_result")
    val SuccessField = new TField("success", TType.STRUCT, 0)
    val SuccessFieldManifest = implicitly[Manifest[UTest]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        SuccessField,
        true,
        SuccessFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: testcmd3$result) {
    }
  
    def withoutPassthroughFields(original: testcmd3$result): testcmd3$result =
      new testcmd3$result(
        success =
          {
            val field = original.success
            field.map { field =>
              UTest.withoutPassthroughFields(field)
            }
          }
      )
  
    override def encode(_item: testcmd3$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): testcmd3$result = {
      var success: Option[UTest] = None
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 =>
              _field.`type` match {
                case TType.STRUCT => {
                  success = Some(readSuccessValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.STRUCT
            
                  throw new TProtocolException(
                    "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new testcmd3$result(
        success,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      success: Option[UTest] = None
    ): testcmd3$result =
      new testcmd3$result(
        success
      )
  
    def unapply(_item: testcmd3$result): Option[Option[UTest]] = Some(_item.success)
  
    implicit val jsonReadCodec = new ReadCodec[testcmd3$result] {
      def read(json: Json) = {
        val map = ReadCodec.castOrThrow(json)
              val fieldValuesuccess = map.getOrElse("success", jnull)
      
        testcmd3$result(      success = Try(com.persist.json.read[Option[UTest]](fieldValuesuccess)).recover {
          case MappingException(msg, path) => throw MappingException(msg, s"success/$path")
        }.get
      
        )
      }
     }
    implicit val jsonWriteCodec = new WriteCodec[testcmd3$result] {
      def write(obj: testcmd3$result) = {
        val fields = List(        if(obj.success.isDefined) Some("success" -> com.persist.json.toJson(obj.success.get)) else None
        
        )
        fields.flatten.toMap
      }
    }
  
    import com.twitter.scrooge.serialization._
  
    implicit val thriftCodec = new ThriftCodec[testcmd3$result] {
      def decode(protocol: TProtocol): testcmd3$result = testcmd3$result.decode(protocol)
      def encode(obj: testcmd3$result, protocol: TProtocol) { testcmd3$result.encode(obj, protocol) }
    }
  
    private def readSuccessValue(_iprot: TProtocol): UTest = {
      UTest.decode(_iprot)
    }
  
    private def writeSuccessField(success_item: UTest, _oprot: TProtocol) {
      _oprot.writeFieldBegin(SuccessField)
      writeSuccessValue(success_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeSuccessValue(success_item: UTest, _oprot: TProtocol) {
      success_item.write(_oprot)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class testcmd3$result(
      val success: Option[UTest],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[Option[UTest]]
    with java.io.Serializable
  {
    import testcmd3$result._
      def this(
        success: Option[UTest] = None
      ) = this(
        success,
        Map.empty
      )
  
    def _1 = success
  
  
    override def write(_oprot: TProtocol) {
      testcmd3$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) writeSuccessField(success.get, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[UTest] = this.success,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): testcmd3$result =
      new testcmd3$result(
        success,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[testcmd3$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[testcmd3$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.success
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "testcmd3$result"
  }
  
  import com.persist.JsonOps._
  import com.persist.json._
  import com.persist.Exceptions.MappingException
  import scala.util.Try
  
  
  object shortIdToUuid$args extends ThriftStructCodec3[shortIdToUuid$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("shortIdToUuid_args")
    val IdsField = new TField("ids", TType.STRING, 1)
    val IdsFieldManifest = implicitly[Manifest[String]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        IdsField,
        false,
        IdsFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: shortIdToUuid$args) {
    }
  
    def withoutPassthroughFields(original: shortIdToUuid$args): shortIdToUuid$args =
      new shortIdToUuid$args(
        ids =
          {
            val field = original.ids
            field
          }
      )
  
    override def encode(_item: shortIdToUuid$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): shortIdToUuid$args = {
      var ids: String = null
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 =>
              _field.`type` match {
                case TType.STRING => {
                  ids = readIdsValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.STRING
            
                  throw new TProtocolException(
                    "Received wrong type for field 'ids' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new shortIdToUuid$args(
        ids,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      ids: String
    ): shortIdToUuid$args =
      new shortIdToUuid$args(
        ids
      )
  
    def unapply(_item: shortIdToUuid$args): Option[String] = Some(_item.ids)
  
    implicit val jsonReadCodec = new ReadCodec[shortIdToUuid$args] {
      def read(json: Json) = {
        val map = ReadCodec.castOrThrow(json)
              val fieldValueids = map.getOrElse("ids", throw new MappingException(s"Expected field ids on JsonObject $map"))
      
        shortIdToUuid$args(      ids = Try(com.persist.json.read[String](fieldValueids)).recover {
          case MappingException(msg, path) => throw MappingException(msg, s"ids/$path")
        }.get
      
        )
      }
     }
    implicit val jsonWriteCodec = new WriteCodec[shortIdToUuid$args] {
      def write(obj: shortIdToUuid$args) = {
        val fields = List(        
          Some("ids" -> com.persist.json.toJson(obj.ids))
        )
        fields.flatten.toMap
      }
    }
  
    import com.twitter.scrooge.serialization._
  
    implicit val thriftCodec = new ThriftCodec[shortIdToUuid$args] {
      def decode(protocol: TProtocol): shortIdToUuid$args = shortIdToUuid$args.decode(protocol)
      def encode(obj: shortIdToUuid$args, protocol: TProtocol) { shortIdToUuid$args.encode(obj, protocol) }
    }
  
    private def readIdsValue(_iprot: TProtocol): String = {
      _iprot.readString()
    }
  
    private def writeIdsField(ids_item: String, _oprot: TProtocol) {
      _oprot.writeFieldBegin(IdsField)
      writeIdsValue(ids_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeIdsValue(ids_item: String, _oprot: TProtocol) {
      _oprot.writeString(ids_item)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class shortIdToUuid$args(
      val ids: String,
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[String]
    with java.io.Serializable
  {
    import shortIdToUuid$args._
      def this(
        ids: String
      ) = this(
        ids,
        Map.empty
      )
  
    def _1 = ids
  
  
    override def write(_oprot: TProtocol) {
      shortIdToUuid$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (ids ne null) writeIdsField(ids, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      ids: String = this.ids,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): shortIdToUuid$args =
      new shortIdToUuid$args(
        ids,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[shortIdToUuid$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[shortIdToUuid$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.ids
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "shortIdToUuid$args"
  }
  
  import com.persist.JsonOps._
  import com.persist.json._
  import com.persist.Exceptions.MappingException
  import scala.util.Try
  
  
  object shortIdToUuid$result extends ThriftStructCodec3[shortIdToUuid$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("shortIdToUuid_result")
    val SuccessField = new TField("success", TType.STRING, 0)
    val SuccessFieldManifest = implicitly[Manifest[String]]
    val EField = new TField("e", TType.STRUCT, 1)
    val EFieldManifest = implicitly[Manifest[ServerException]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        SuccessField,
        true,
        SuccessFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      ),
      new ThriftStructFieldInfo(
        EField,
        true,
        EFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: shortIdToUuid$result) {
    }
  
    def withoutPassthroughFields(original: shortIdToUuid$result): shortIdToUuid$result =
      new shortIdToUuid$result(
        success =
          {
            val field = original.success
            field.map { field =>
              field
            }
          },
        e =
          {
            val field = original.e
            field.map { field =>
              ServerException.withoutPassthroughFields(field)
            }
          }
      )
  
    override def encode(_item: shortIdToUuid$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): shortIdToUuid$result = {
      var success: Option[String] = None
      var e: Option[ServerException] = None
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 =>
              _field.`type` match {
                case TType.STRING => {
                  success = Some(readSuccessValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.STRING
            
                  throw new TProtocolException(
                    "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case 1 =>
              _field.`type` match {
                case TType.STRUCT => {
                  e = Some(readEValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.STRUCT
            
                  throw new TProtocolException(
                    "Received wrong type for field 'e' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new shortIdToUuid$result(
        success,
        e,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      success: Option[String] = None,
      e: Option[ServerException] = None
    ): shortIdToUuid$result =
      new shortIdToUuid$result(
        success,
        e
      )
  
    def unapply(_item: shortIdToUuid$result): Option[scala.Product2[Option[String], Option[ServerException]]] = Some(_item)
  
    implicit val jsonReadCodec = new ReadCodec[shortIdToUuid$result] {
      def read(json: Json) = {
        val map = ReadCodec.castOrThrow(json)
              val fieldValuesuccess = map.getOrElse("success", jnull)
              val fieldValuee = map.getOrElse("e", jnull)
      
        shortIdToUuid$result(      success = Try(com.persist.json.read[Option[String]](fieldValuesuccess)).recover {
          case MappingException(msg, path) => throw MappingException(msg, s"success/$path")
        }.get
        ,      e = Try(com.persist.json.read[Option[ServerException]](fieldValuee)).recover {
          case MappingException(msg, path) => throw MappingException(msg, s"e/$path")
        }.get
      
        )
      }
     }
    implicit val jsonWriteCodec = new WriteCodec[shortIdToUuid$result] {
      def write(obj: shortIdToUuid$result) = {
        val fields = List(        if(obj.success.isDefined) Some("success" -> com.persist.json.toJson(obj.success.get)) else None
          ,        if(obj.e.isDefined) Some("e" -> com.persist.json.toJson(obj.e.get)) else None
        
        )
        fields.flatten.toMap
      }
    }
  
    import com.twitter.scrooge.serialization._
  
    implicit val thriftCodec = new ThriftCodec[shortIdToUuid$result] {
      def decode(protocol: TProtocol): shortIdToUuid$result = shortIdToUuid$result.decode(protocol)
      def encode(obj: shortIdToUuid$result, protocol: TProtocol) { shortIdToUuid$result.encode(obj, protocol) }
    }
  
    private def readSuccessValue(_iprot: TProtocol): String = {
      _iprot.readString()
    }
  
    private def writeSuccessField(success_item: String, _oprot: TProtocol) {
      _oprot.writeFieldBegin(SuccessField)
      writeSuccessValue(success_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeSuccessValue(success_item: String, _oprot: TProtocol) {
      _oprot.writeString(success_item)
    }
  
    private def readEValue(_iprot: TProtocol): ServerException = {
      ServerException.decode(_iprot)
    }
  
    private def writeEField(e_item: ServerException, _oprot: TProtocol) {
      _oprot.writeFieldBegin(EField)
      writeEValue(e_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeEValue(e_item: ServerException, _oprot: TProtocol) {
      e_item.write(_oprot)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class shortIdToUuid$result(
      val success: Option[String],
      val e: Option[ServerException],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product2[Option[String], Option[ServerException]]
    with java.io.Serializable
  {
    import shortIdToUuid$result._
      def this(
        success: Option[String] = None,
        e: Option[ServerException] = None
      ) = this(
        success,
        e,
        Map.empty
      )
  
    def _1 = success
    def _2 = e
  
  
    override def write(_oprot: TProtocol) {
      shortIdToUuid$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) writeSuccessField(success.get, _oprot)
      if (e.isDefined) writeEField(e.get, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[String] = this.success,
      e: Option[ServerException] = this.e,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): shortIdToUuid$result =
      new shortIdToUuid$result(
        success,
        e,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[shortIdToUuid$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[shortIdToUuid$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 2
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.success
      case 1 => this.e
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "shortIdToUuid$result"
  }
  
  import com.persist.JsonOps._
  import com.persist.json._
  import com.persist.Exceptions.MappingException
  import scala.util.Try
  
  
  object casechecker$args extends ThriftStructCodec3[casechecker$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("casechecker_args")
    val CaseCheckerField = new TField("case_checker", TType.STRUCT, 1)
    val CaseCheckerFieldManifest = implicitly[Manifest[CaseChecker]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        CaseCheckerField,
        false,
        CaseCheckerFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: casechecker$args) {
    }
  
    def withoutPassthroughFields(original: casechecker$args): casechecker$args =
      new casechecker$args(
        caseChecker =
          {
            val field = original.caseChecker
            CaseChecker.withoutPassthroughFields(field)
          }
      )
  
    override def encode(_item: casechecker$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): casechecker$args = {
      var caseChecker: CaseChecker = null
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 =>
              _field.`type` match {
                case TType.STRUCT => {
                  caseChecker = readCaseCheckerValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.STRUCT
            
                  throw new TProtocolException(
                    "Received wrong type for field 'caseChecker' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new casechecker$args(
        caseChecker,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      caseChecker: CaseChecker
    ): casechecker$args =
      new casechecker$args(
        caseChecker
      )
  
    def unapply(_item: casechecker$args): Option[CaseChecker] = Some(_item.caseChecker)
  
    implicit val jsonReadCodec = new ReadCodec[casechecker$args] {
      def read(json: Json) = {
        val map = ReadCodec.castOrThrow(json)
              val fieldValuecase_checker = map.getOrElse("case_checker", throw new MappingException(s"Expected field case_checker on JsonObject $map"))
      
        casechecker$args(      caseChecker = Try(com.persist.json.read[CaseChecker](fieldValuecase_checker)).recover {
          case MappingException(msg, path) => throw MappingException(msg, s"case_checker/$path")
        }.get
      
        )
      }
     }
    implicit val jsonWriteCodec = new WriteCodec[casechecker$args] {
      def write(obj: casechecker$args) = {
        val fields = List(        
          Some("case_checker" -> com.persist.json.toJson(obj.caseChecker))
        )
        fields.flatten.toMap
      }
    }
  
    import com.twitter.scrooge.serialization._
  
    implicit val thriftCodec = new ThriftCodec[casechecker$args] {
      def decode(protocol: TProtocol): casechecker$args = casechecker$args.decode(protocol)
      def encode(obj: casechecker$args, protocol: TProtocol) { casechecker$args.encode(obj, protocol) }
    }
  
    private def readCaseCheckerValue(_iprot: TProtocol): CaseChecker = {
      CaseChecker.decode(_iprot)
    }
  
    private def writeCaseCheckerField(caseChecker_item: CaseChecker, _oprot: TProtocol) {
      _oprot.writeFieldBegin(CaseCheckerField)
      writeCaseCheckerValue(caseChecker_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeCaseCheckerValue(caseChecker_item: CaseChecker, _oprot: TProtocol) {
      caseChecker_item.write(_oprot)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class casechecker$args(
      val caseChecker: CaseChecker,
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[CaseChecker]
    with java.io.Serializable
  {
    import casechecker$args._
      def this(
        caseChecker: CaseChecker
      ) = this(
        caseChecker,
        Map.empty
      )
  
    def _1 = caseChecker
  
  
    override def write(_oprot: TProtocol) {
      casechecker$args.validate(this)
      _oprot.writeStructBegin(Struct)
      if (caseChecker ne null) writeCaseCheckerField(caseChecker, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      caseChecker: CaseChecker = this.caseChecker,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): casechecker$args =
      new casechecker$args(
        caseChecker,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[casechecker$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[casechecker$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.caseChecker
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "casechecker$args"
  }
  
  import com.persist.JsonOps._
  import com.persist.json._
  import com.persist.Exceptions.MappingException
  import scala.util.Try
  
  
  object casechecker$result extends ThriftStructCodec3[casechecker$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("casechecker_result")
    val SuccessField = new TField("success", TType.STRUCT, 0)
    val SuccessFieldManifest = implicitly[Manifest[CaseChecker]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        SuccessField,
        true,
        SuccessFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: casechecker$result) {
    }
  
    def withoutPassthroughFields(original: casechecker$result): casechecker$result =
      new casechecker$result(
        success =
          {
            val field = original.success
            field.map { field =>
              CaseChecker.withoutPassthroughFields(field)
            }
          }
      )
  
    override def encode(_item: casechecker$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): casechecker$result = {
      var success: Option[CaseChecker] = None
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 =>
              _field.`type` match {
                case TType.STRUCT => {
                  success = Some(readSuccessValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.STRUCT
            
                  throw new TProtocolException(
                    "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new casechecker$result(
        success,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      success: Option[CaseChecker] = None
    ): casechecker$result =
      new casechecker$result(
        success
      )
  
    def unapply(_item: casechecker$result): Option[Option[CaseChecker]] = Some(_item.success)
  
    implicit val jsonReadCodec = new ReadCodec[casechecker$result] {
      def read(json: Json) = {
        val map = ReadCodec.castOrThrow(json)
              val fieldValuesuccess = map.getOrElse("success", jnull)
      
        casechecker$result(      success = Try(com.persist.json.read[Option[CaseChecker]](fieldValuesuccess)).recover {
          case MappingException(msg, path) => throw MappingException(msg, s"success/$path")
        }.get
      
        )
      }
     }
    implicit val jsonWriteCodec = new WriteCodec[casechecker$result] {
      def write(obj: casechecker$result) = {
        val fields = List(        if(obj.success.isDefined) Some("success" -> com.persist.json.toJson(obj.success.get)) else None
        
        )
        fields.flatten.toMap
      }
    }
  
    import com.twitter.scrooge.serialization._
  
    implicit val thriftCodec = new ThriftCodec[casechecker$result] {
      def decode(protocol: TProtocol): casechecker$result = casechecker$result.decode(protocol)
      def encode(obj: casechecker$result, protocol: TProtocol) { casechecker$result.encode(obj, protocol) }
    }
  
    private def readSuccessValue(_iprot: TProtocol): CaseChecker = {
      CaseChecker.decode(_iprot)
    }
  
    private def writeSuccessField(success_item: CaseChecker, _oprot: TProtocol) {
      _oprot.writeFieldBegin(SuccessField)
      writeSuccessValue(success_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeSuccessValue(success_item: CaseChecker, _oprot: TProtocol) {
      success_item.write(_oprot)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class casechecker$result(
      val success: Option[CaseChecker],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[Option[CaseChecker]]
    with java.io.Serializable
  {
    import casechecker$result._
      def this(
        success: Option[CaseChecker] = None
      ) = this(
        success,
        Map.empty
      )
  
    def _1 = success
  
  
    override def write(_oprot: TProtocol) {
      casechecker$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) writeSuccessField(success.get, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[CaseChecker] = this.success,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): casechecker$result =
      new casechecker$result(
        success,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[casechecker$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[casechecker$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.success
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "casechecker$result"
  }
  
  import com.persist.JsonOps._
  import com.persist.json._
  import com.persist.Exceptions.MappingException
  import scala.util.Try
  
  
  object camelCase$args extends ThriftStructCodec3[camelCase$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("camelCase_args")
    val IField = new TField("i", TType.I32, 1)
    val IFieldManifest = implicitly[Manifest[Int]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        IField,
        false,
        IFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: camelCase$args) {
    }
  
    def withoutPassthroughFields(original: camelCase$args): camelCase$args =
      new camelCase$args(
        i =
          {
            val field = original.i
            field
          }
      )
  
    override def encode(_item: camelCase$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): camelCase$args = {
      var i: Int = 0
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 =>
              _field.`type` match {
                case TType.I32 => {
                  i = readIValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.I32
            
                  throw new TProtocolException(
                    "Received wrong type for field 'i' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new camelCase$args(
        i,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      i: Int
    ): camelCase$args =
      new camelCase$args(
        i
      )
  
    def unapply(_item: camelCase$args): Option[Int] = Some(_item.i)
  
    implicit val jsonReadCodec = new ReadCodec[camelCase$args] {
      def read(json: Json) = {
        val map = ReadCodec.castOrThrow(json)
              val fieldValuei = map.getOrElse("i", throw new MappingException(s"Expected field i on JsonObject $map"))
      
        camelCase$args(      i = Try(com.persist.json.read[Int](fieldValuei)).recover {
          case MappingException(msg, path) => throw MappingException(msg, s"i/$path")
        }.get
      
        )
      }
     }
    implicit val jsonWriteCodec = new WriteCodec[camelCase$args] {
      def write(obj: camelCase$args) = {
        val fields = List(        
          Some("i" -> com.persist.json.toJson(obj.i))
        )
        fields.flatten.toMap
      }
    }
  
    import com.twitter.scrooge.serialization._
  
    implicit val thriftCodec = new ThriftCodec[camelCase$args] {
      def decode(protocol: TProtocol): camelCase$args = camelCase$args.decode(protocol)
      def encode(obj: camelCase$args, protocol: TProtocol) { camelCase$args.encode(obj, protocol) }
    }
  
    private def readIValue(_iprot: TProtocol): Int = {
      _iprot.readI32()
    }
  
    private def writeIField(i_item: Int, _oprot: TProtocol) {
      _oprot.writeFieldBegin(IField)
      writeIValue(i_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeIValue(i_item: Int, _oprot: TProtocol) {
      _oprot.writeI32(i_item)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class camelCase$args(
      val i: Int,
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[Int]
    with java.io.Serializable
  {
    import camelCase$args._
      def this(
        i: Int
      ) = this(
        i,
        Map.empty
      )
  
    def _1 = i
  
  
    override def write(_oprot: TProtocol) {
      camelCase$args.validate(this)
      _oprot.writeStructBegin(Struct)
      writeIField(i, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      i: Int = this.i,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): camelCase$args =
      new camelCase$args(
        i,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[camelCase$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[camelCase$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.i
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "camelCase$args"
  }
  
  import com.persist.JsonOps._
  import com.persist.json._
  import com.persist.Exceptions.MappingException
  import scala.util.Try
  
  
  object camelCase$result extends ThriftStructCodec3[camelCase$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("camelCase_result")
    val SuccessField = new TField("success", TType.I32, 0)
    val SuccessFieldManifest = implicitly[Manifest[Int]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        SuccessField,
        true,
        SuccessFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: camelCase$result) {
    }
  
    def withoutPassthroughFields(original: camelCase$result): camelCase$result =
      new camelCase$result(
        success =
          {
            val field = original.success
            field.map { field =>
              field
            }
          }
      )
  
    override def encode(_item: camelCase$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): camelCase$result = {
      var success: Option[Int] = None
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 =>
              _field.`type` match {
                case TType.I32 => {
                  success = Some(readSuccessValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.I32
            
                  throw new TProtocolException(
                    "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new camelCase$result(
        success,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      success: Option[Int] = None
    ): camelCase$result =
      new camelCase$result(
        success
      )
  
    def unapply(_item: camelCase$result): Option[Option[Int]] = Some(_item.success)
  
    implicit val jsonReadCodec = new ReadCodec[camelCase$result] {
      def read(json: Json) = {
        val map = ReadCodec.castOrThrow(json)
              val fieldValuesuccess = map.getOrElse("success", jnull)
      
        camelCase$result(      success = Try(com.persist.json.read[Option[Int]](fieldValuesuccess)).recover {
          case MappingException(msg, path) => throw MappingException(msg, s"success/$path")
        }.get
      
        )
      }
     }
    implicit val jsonWriteCodec = new WriteCodec[camelCase$result] {
      def write(obj: camelCase$result) = {
        val fields = List(        if(obj.success.isDefined) Some("success" -> com.persist.json.toJson(obj.success.get)) else None
        
        )
        fields.flatten.toMap
      }
    }
  
    import com.twitter.scrooge.serialization._
  
    implicit val thriftCodec = new ThriftCodec[camelCase$result] {
      def decode(protocol: TProtocol): camelCase$result = camelCase$result.decode(protocol)
      def encode(obj: camelCase$result, protocol: TProtocol) { camelCase$result.encode(obj, protocol) }
    }
  
    private def readSuccessValue(_iprot: TProtocol): Int = {
      _iprot.readI32()
    }
  
    private def writeSuccessField(success_item: Int, _oprot: TProtocol) {
      _oprot.writeFieldBegin(SuccessField)
      writeSuccessValue(success_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeSuccessValue(success_item: Int, _oprot: TProtocol) {
      _oprot.writeI32(success_item)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class camelCase$result(
      val success: Option[Int],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[Option[Int]]
    with java.io.Serializable
  {
    import camelCase$result._
      def this(
        success: Option[Int] = None
      ) = this(
        success,
        Map.empty
      )
  
    def _1 = success
  
  
    override def write(_oprot: TProtocol) {
      camelCase$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) writeSuccessField(success.get, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[Int] = this.success,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): camelCase$result =
      new camelCase$result(
        success,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[camelCase$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[camelCase$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.success
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "camelCase$result"
  }
  
  import com.persist.JsonOps._
  import com.persist.json._
  import com.persist.Exceptions.MappingException
  import scala.util.Try
  
  
  object snakeCase$args extends ThriftStructCodec3[snakeCase$args] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("snake_case_args")
    val IField = new TField("i", TType.I32, 1)
    val IFieldManifest = implicitly[Manifest[Int]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        IField,
        false,
        IFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: snakeCase$args) {
    }
  
    def withoutPassthroughFields(original: snakeCase$args): snakeCase$args =
      new snakeCase$args(
        i =
          {
            val field = original.i
            field
          }
      )
  
    override def encode(_item: snakeCase$args, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): snakeCase$args = {
      var i: Int = 0
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 =>
              _field.`type` match {
                case TType.I32 => {
                  i = readIValue(_iprot)
                }
                case _actualType =>
                  val _expectedType = TType.I32
            
                  throw new TProtocolException(
                    "Received wrong type for field 'i' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new snakeCase$args(
        i,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      i: Int
    ): snakeCase$args =
      new snakeCase$args(
        i
      )
  
    def unapply(_item: snakeCase$args): Option[Int] = Some(_item.i)
  
    implicit val jsonReadCodec = new ReadCodec[snakeCase$args] {
      def read(json: Json) = {
        val map = ReadCodec.castOrThrow(json)
              val fieldValuei = map.getOrElse("i", throw new MappingException(s"Expected field i on JsonObject $map"))
      
        snakeCase$args(      i = Try(com.persist.json.read[Int](fieldValuei)).recover {
          case MappingException(msg, path) => throw MappingException(msg, s"i/$path")
        }.get
      
        )
      }
     }
    implicit val jsonWriteCodec = new WriteCodec[snakeCase$args] {
      def write(obj: snakeCase$args) = {
        val fields = List(        
          Some("i" -> com.persist.json.toJson(obj.i))
        )
        fields.flatten.toMap
      }
    }
  
    import com.twitter.scrooge.serialization._
  
    implicit val thriftCodec = new ThriftCodec[snakeCase$args] {
      def decode(protocol: TProtocol): snakeCase$args = snakeCase$args.decode(protocol)
      def encode(obj: snakeCase$args, protocol: TProtocol) { snakeCase$args.encode(obj, protocol) }
    }
  
    private def readIValue(_iprot: TProtocol): Int = {
      _iprot.readI32()
    }
  
    private def writeIField(i_item: Int, _oprot: TProtocol) {
      _oprot.writeFieldBegin(IField)
      writeIValue(i_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeIValue(i_item: Int, _oprot: TProtocol) {
      _oprot.writeI32(i_item)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class snakeCase$args(
      val i: Int,
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[Int]
    with java.io.Serializable
  {
    import snakeCase$args._
      def this(
        i: Int
      ) = this(
        i,
        Map.empty
      )
  
    def _1 = i
  
  
    override def write(_oprot: TProtocol) {
      snakeCase$args.validate(this)
      _oprot.writeStructBegin(Struct)
      writeIField(i, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      i: Int = this.i,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): snakeCase$args =
      new snakeCase$args(
        i,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[snakeCase$args]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[snakeCase$args]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.i
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "snakeCase$args"
  }
  
  import com.persist.JsonOps._
  import com.persist.json._
  import com.persist.Exceptions.MappingException
  import scala.util.Try
  
  
  object snakeCase$result extends ThriftStructCodec3[snakeCase$result] {
    private val NoPassthroughFields = immutable$Map.empty[Short, TFieldBlob]
    val Struct = new TStruct("snake_case_result")
    val SuccessField = new TField("success", TType.I32, 0)
    val SuccessFieldManifest = implicitly[Manifest[Int]]
  
    /**
     * Field information in declaration order.
     */
    lazy val fieldInfos: scala.List[ThriftStructFieldInfo] = scala.List[ThriftStructFieldInfo](
      new ThriftStructFieldInfo(
        SuccessField,
        true,
        SuccessFieldManifest,
        None,
        None,
        immutable$Map(
        ),
        immutable$Map(
        )
      )
    )
  
    lazy val structAnnotations: immutable$Map[String, String] =
      immutable$Map[String, String](
      )
  
    /**
     * Checks that all required fields are non-null.
     */
    def validate(_item: snakeCase$result) {
    }
  
    def withoutPassthroughFields(original: snakeCase$result): snakeCase$result =
      new snakeCase$result(
        success =
          {
            val field = original.success
            field.map { field =>
              field
            }
          }
      )
  
    override def encode(_item: snakeCase$result, _oproto: TProtocol) {
      _item.write(_oproto)
    }
  
    override def decode(_iprot: TProtocol): snakeCase$result = {
      var success: Option[Int] = None
      var _passthroughFields: Builder[(Short, TFieldBlob), immutable$Map[Short, TFieldBlob]] = null
      var _done = false
  
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 0 =>
              _field.`type` match {
                case TType.I32 => {
                  success = Some(readSuccessValue(_iprot))
                }
                case _actualType =>
                  val _expectedType = TType.I32
            
                  throw new TProtocolException(
                    "Received wrong type for field 'success' (expected=%s, actual=%s).".format(
                      ttypeToHuman(_expectedType),
                      ttypeToHuman(_actualType)
                    )
                  )
              }
            case _ =>
              if (_passthroughFields == null)
                _passthroughFields = immutable$Map.newBuilder[Short, TFieldBlob]
              _passthroughFields += (_field.id -> TFieldBlob.read(_field, _iprot))
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
  
      new snakeCase$result(
        success,
        if (_passthroughFields == null)
          NoPassthroughFields
        else
          _passthroughFields.result()
      )
    }
  
    def apply(
      success: Option[Int] = None
    ): snakeCase$result =
      new snakeCase$result(
        success
      )
  
    def unapply(_item: snakeCase$result): Option[Option[Int]] = Some(_item.success)
  
    implicit val jsonReadCodec = new ReadCodec[snakeCase$result] {
      def read(json: Json) = {
        val map = ReadCodec.castOrThrow(json)
              val fieldValuesuccess = map.getOrElse("success", jnull)
      
        snakeCase$result(      success = Try(com.persist.json.read[Option[Int]](fieldValuesuccess)).recover {
          case MappingException(msg, path) => throw MappingException(msg, s"success/$path")
        }.get
      
        )
      }
     }
    implicit val jsonWriteCodec = new WriteCodec[snakeCase$result] {
      def write(obj: snakeCase$result) = {
        val fields = List(        if(obj.success.isDefined) Some("success" -> com.persist.json.toJson(obj.success.get)) else None
        
        )
        fields.flatten.toMap
      }
    }
  
    import com.twitter.scrooge.serialization._
  
    implicit val thriftCodec = new ThriftCodec[snakeCase$result] {
      def decode(protocol: TProtocol): snakeCase$result = snakeCase$result.decode(protocol)
      def encode(obj: snakeCase$result, protocol: TProtocol) { snakeCase$result.encode(obj, protocol) }
    }
  
    private def readSuccessValue(_iprot: TProtocol): Int = {
      _iprot.readI32()
    }
  
    private def writeSuccessField(success_item: Int, _oprot: TProtocol) {
      _oprot.writeFieldBegin(SuccessField)
      writeSuccessValue(success_item, _oprot)
      _oprot.writeFieldEnd()
    }
  
    private def writeSuccessValue(success_item: Int, _oprot: TProtocol) {
      _oprot.writeI32(success_item)
    }
  
  
  
    private def ttypeToHuman(byte: Byte) = {
      // from https://github.com/apache/thrift/blob/master/lib/java/src/org/apache/thrift/protocol/TType.java
      byte match {
        case TType.STOP   => "STOP"
        case TType.VOID   => "VOID"
        case TType.BOOL   => "BOOL"
        case TType.BYTE   => "BYTE"
        case TType.DOUBLE => "DOUBLE"
        case TType.I16    => "I16"
        case TType.I32    => "I32"
        case TType.I64    => "I64"
        case TType.STRING => "STRING"
        case TType.STRUCT => "STRUCT"
        case TType.MAP    => "MAP"
        case TType.SET    => "SET"
        case TType.LIST   => "LIST"
        case TType.ENUM   => "ENUM"
        case _            => "UNKNOWN"
      }
    }
  
  }
  
  class snakeCase$result(
      val success: Option[Int],
      val _passthroughFields: immutable$Map[Short, TFieldBlob])
    extends ThriftStruct
    with scala.Product1[Option[Int]]
    with java.io.Serializable
  {
    import snakeCase$result._
      def this(
        success: Option[Int] = None
      ) = this(
        success,
        Map.empty
      )
  
    def _1 = success
  
  
    override def write(_oprot: TProtocol) {
      snakeCase$result.validate(this)
      _oprot.writeStructBegin(Struct)
      if (success.isDefined) writeSuccessField(success.get, _oprot)
      _passthroughFields.values foreach { _.write(_oprot) }
      _oprot.writeFieldStop()
      _oprot.writeStructEnd()
    }
  
    def copy(
      success: Option[Int] = this.success,
      _passthroughFields: immutable$Map[Short, TFieldBlob] = this._passthroughFields
    ): snakeCase$result =
      new snakeCase$result(
        success,
        _passthroughFields
      )
  
    override def canEqual(other: Any): Boolean = other.isInstanceOf[snakeCase$result]
  
    override def equals(other: Any): Boolean =
      _root_.scala.runtime.ScalaRunTime._equals(this, other) &&
        _passthroughFields == other.asInstanceOf[snakeCase$result]._passthroughFields
  
    override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)
  
    override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)
  
  
    override def productArity: Int = 1
  
    override def productElement(n: Int): Any = n match {
      case 0 => this.success
      case _ => throw new IndexOutOfBoundsException(n.toString)
    }
  
    override def productPrefix: String = "snakeCase$result"
  }


import com.twitter.scrooge.{Info, TInfo}

def map: Map[String, Info] = Map(  "testcmd" -> Info(
                      TInfo[testcmd$args](
                        is = (t: testcmd$args) => t.isInstanceOf[testcmd$args],
                        readCodec = testcmd$args.jsonReadCodec,
                        writeCodec = testcmd$args.jsonWriteCodec,
                        companion = testcmd$args).asInstanceOf[TInfo[ThriftStruct]],
                      TInfo[testcmd$result](
                        is = (t: testcmd$result) => t.isInstanceOf[testcmd$result],
                        readCodec = testcmd$result.jsonReadCodec,
                        writeCodec = testcmd$result.jsonWriteCodec,
                        companion = testcmd$result).asInstanceOf[TInfo[ThriftStruct]]),
  "testcmd1" -> Info(
                      TInfo[testcmd1$args](
                        is = (t: testcmd1$args) => t.isInstanceOf[testcmd1$args],
                        readCodec = testcmd1$args.jsonReadCodec,
                        writeCodec = testcmd1$args.jsonWriteCodec,
                        companion = testcmd1$args).asInstanceOf[TInfo[ThriftStruct]],
                      TInfo[testcmd1$result](
                        is = (t: testcmd1$result) => t.isInstanceOf[testcmd1$result],
                        readCodec = testcmd1$result.jsonReadCodec,
                        writeCodec = testcmd1$result.jsonWriteCodec,
                        companion = testcmd1$result).asInstanceOf[TInfo[ThriftStruct]]),
  "testcmd2" -> Info(
                      TInfo[testcmd2$args](
                        is = (t: testcmd2$args) => t.isInstanceOf[testcmd2$args],
                        readCodec = testcmd2$args.jsonReadCodec,
                        writeCodec = testcmd2$args.jsonWriteCodec,
                        companion = testcmd2$args).asInstanceOf[TInfo[ThriftStruct]],
                      TInfo[testcmd2$result](
                        is = (t: testcmd2$result) => t.isInstanceOf[testcmd2$result],
                        readCodec = testcmd2$result.jsonReadCodec,
                        writeCodec = testcmd2$result.jsonWriteCodec,
                        companion = testcmd2$result).asInstanceOf[TInfo[ThriftStruct]]),
  "testcmd3" -> Info(
                      TInfo[testcmd3$args](
                        is = (t: testcmd3$args) => t.isInstanceOf[testcmd3$args],
                        readCodec = testcmd3$args.jsonReadCodec,
                        writeCodec = testcmd3$args.jsonWriteCodec,
                        companion = testcmd3$args).asInstanceOf[TInfo[ThriftStruct]],
                      TInfo[testcmd3$result](
                        is = (t: testcmd3$result) => t.isInstanceOf[testcmd3$result],
                        readCodec = testcmd3$result.jsonReadCodec,
                        writeCodec = testcmd3$result.jsonWriteCodec,
                        companion = testcmd3$result).asInstanceOf[TInfo[ThriftStruct]]),
  "shortIdToUuid" -> Info(
                      TInfo[shortIdToUuid$args](
                        is = (t: shortIdToUuid$args) => t.isInstanceOf[shortIdToUuid$args],
                        readCodec = shortIdToUuid$args.jsonReadCodec,
                        writeCodec = shortIdToUuid$args.jsonWriteCodec,
                        companion = shortIdToUuid$args).asInstanceOf[TInfo[ThriftStruct]],
                      TInfo[shortIdToUuid$result](
                        is = (t: shortIdToUuid$result) => t.isInstanceOf[shortIdToUuid$result],
                        readCodec = shortIdToUuid$result.jsonReadCodec,
                        writeCodec = shortIdToUuid$result.jsonWriteCodec,
                        companion = shortIdToUuid$result).asInstanceOf[TInfo[ThriftStruct]]),
  "casechecker" -> Info(
                      TInfo[casechecker$args](
                        is = (t: casechecker$args) => t.isInstanceOf[casechecker$args],
                        readCodec = casechecker$args.jsonReadCodec,
                        writeCodec = casechecker$args.jsonWriteCodec,
                        companion = casechecker$args).asInstanceOf[TInfo[ThriftStruct]],
                      TInfo[casechecker$result](
                        is = (t: casechecker$result) => t.isInstanceOf[casechecker$result],
                        readCodec = casechecker$result.jsonReadCodec,
                        writeCodec = casechecker$result.jsonWriteCodec,
                        companion = casechecker$result).asInstanceOf[TInfo[ThriftStruct]]),
  "camelCase" -> Info(
                      TInfo[camelCase$args](
                        is = (t: camelCase$args) => t.isInstanceOf[camelCase$args],
                        readCodec = camelCase$args.jsonReadCodec,
                        writeCodec = camelCase$args.jsonWriteCodec,
                        companion = camelCase$args).asInstanceOf[TInfo[ThriftStruct]],
                      TInfo[camelCase$result](
                        is = (t: camelCase$result) => t.isInstanceOf[camelCase$result],
                        readCodec = camelCase$result.jsonReadCodec,
                        writeCodec = camelCase$result.jsonWriteCodec,
                        companion = camelCase$result).asInstanceOf[TInfo[ThriftStruct]]),
  "snakeCase" -> Info(
                      TInfo[snakeCase$args](
                        is = (t: snakeCase$args) => t.isInstanceOf[snakeCase$args],
                        readCodec = snakeCase$args.jsonReadCodec,
                        writeCodec = snakeCase$args.jsonWriteCodec,
                        companion = snakeCase$args).asInstanceOf[TInfo[ThriftStruct]],
                      TInfo[snakeCase$result](
                        is = (t: snakeCase$result) => t.isInstanceOf[snakeCase$result],
                        readCodec = snakeCase$result.jsonReadCodec,
                        writeCodec = snakeCase$result.jsonWriteCodec,
                        companion = snakeCase$result).asInstanceOf[TInfo[ThriftStruct]])

)

}